ООП на простых примерах. Объектно-ориентированное программирование 
# Процедурный подход - стиль был раньше
Просто функция которая что то принимает и что то возвращает 
func Multiple(a int, b int) int{
    return a*b
}
# Объектно-ориентированное программирование
## Определение Класс, Обьект, Метод, Конструктор
### Класс - набор характеристик которым можно охарактеризовать обьект
***Характеристики Класса == Свойства класса**
рост, вес, имя
type Human struct{
    company string
    Name string
    Height float64Интерфейсы
    Weight float64
}
### Обьекты. Представитель класса и есть обьект 
Представитель класса называется обьектом
Vasja := Human{
        company: "Libher",
		Name:   "Vasul",
		Height: 1.87,
		Weight: 82,
	}
***Создание обьекта через конструктор**
Petja:= NewHuman("Petja", 1.66, 77)
### Методы - Действия которые происходят с обьектом
func (h Human) Print() {
	fmt.Println(h.name, h.weight, h.height)
}
***Вызов метода у обьекта**
func main(){
    Vasja.Print()
	Petja.Print()
}
### Конструктор
func NewHuman(newName string, newHeight float64, newWight float64) *Human {
	return &Human{newName, newHeight, newWight}
}
## Принципы ООП - Инкапсуляция и сокрытие, Наследование (Композиция), Полиморфизм (Динамический через интерфейсы)
### Инкапсуляция и сокрытие
***Инкапсуляция** позволяет обьеденить свойства обьекта и методы.
Этот принцип не присущ процедурному програмированию - очень просто
***Сокрытие** - скрытые програмистом характеристики и методы (мелкий шрифт) к которым нет доступа (company string),
- методы на go можно вызвать только внутри пакета
- можно обьявлять с маленькой буквы - и они будут скрыты.
- Гетеры и Сетеры которые позволяют получить доступ к скрытым полям 
// Geter
func (h *Human) GetCompany() string {
	return h.company
}

// Seter Проверка на заглавную
func (h *Human) SetCompany(newCompany string) {
	company := []rune(newCompany)
	if !unicode.IsUpper(company[0]) {
		company[0] = unicode.ToUpper(company[0])
		h.company = string(company)
	} else {
		h.company = newCompany
	}
}
- в случае с уникальным id можно предоставить функции отрабатывать полностью эту функцию и не создавать для него сетера
### Наследование в golang отсутствует но есть Композиция
#### Композиция - характерная черта композиции что НадКласс не может существовать отдельно (машина и колёса)
Отличие Агрегации от композиции - при агригации класс может существовать отдельно от подкласа (ёлочка для авто)
type Worker struct {
	Human
	Expirience int
}

func NewWorker(h Human, NewExp int) *Worker {
	return &Worker{h, NewExp}
}

func (w Worker) Print() {
	w.Human.Print()
	fmt.Println("Expirience: ", w.Expirience, " month")
}
### Полиморфизм (много форм) - один код может работать с разными типами данных
Полиморфизм относится к свойству языка программирования позволять объектам различных типов обрабатываться единообразно. Он обеспечивает возможность использования объектов разных типов через общий интерфейс или базовый класс, без необходимости знать их конкретный тип.
Из за строгой типизации **Параметрический и Мнимый полиморфизмы отсутствуют в Golang хз шо воно таке** - 
#### Динамический полиморфизм Go (полиморфизм на этапе выполнения)
В языке Go (Golang) используется динамический полиморфизм через интерфейсы. Интерфейсы в Go позволяют создавать абстракции, которые позволяют объектам различных типов взаимодействовать с общим набором методов без явного указания конкретного типа.
Преимущество динамического полиморфизма через интерфейсы состоит в том, что вы можете работать с объектами, не зная их конкретных типов, но зная, что они реализуют определенные методы определенного интерфейса.
package main

import "fmt"

type Shape interface {
    Area() float64
}

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

func PrintArea(s Shape) {
    fmt.Println("Area:", s.Area())
}

func main() {
    rectangle := Rectangle{Width: 5, Height: 3}
    circle := Circle{Radius: 2.5}

    PrintArea(rectangle) // Выводит площадь прямоугольника
    PrintArea(circle)    // Выводит площадь круга
}
## Абстрактные Классы и Интерфейсы в Golang
В Golang нет явной поддержки абстрактных классов
**Интерфейсы** в Go представляют абстрактные типы данных, состоящие только из набора методов без реализации. Они определяют контракт, который должен быть выполнен для типа, чтобы он соответствовал интерфейсу. Тип в Go автоматически удовлетворяет интерфейсу, если он реализует все его методы. Это позволяет достичь абстракции и полиморфизма в Go. 
## Dep.Injection
##  Singleton


# SOLID 
## Single Responsibility Principle (Принцип единственной ответственности):
Каждый класс или модуль должен быть ответственным только за одну задачу или функциональность. Он должен иметь только одну причину для изменения.
## Open/Closed Principle (Принцип открытости/закрытости):
Система должна быть открытой для расширения, но закрытой для модификации. Это означает, что новую функциональность можно добавить, не изменяя существующий код.
## Liskov Substitution Principle (Принцип подстановки Лисков):
Объекты в программе должны быть заменяемыми и могут быть использованы вместо своих базовых типов без изменения корректности программы. Это гарантирует, что подклассы не изменяют базовое поведение.
## Interface Segregation Principle (Принцип разделения интерфейсов):
Клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы следует разделять на более мелкие и специфические, чтобы клиенты могли реализовывать только те интерфейсы, которые им действительно нужны.
## Dependency Inversion Principle (Принцип инверсии зависимостей):
Код должен зависеть от абстракций, а не от конкретных реализаций. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.
# Крут - Create, Read (Get), Update, Delete
(CRUD) являются стандартными методами, которые часто используются при проектировании и разработке приложений для работы с базами данных или персистентными хранилищами. Эти методы представляют основные операции над данными:
Create (создание) - метод для создания новой записи или объекта в базе данных или хранилище.
Read (Get) (чтение) - метод для получения существующей записи или объекта из базы данных или хранилища.
Update (обновление) - метод для изменения существующей записи или объекта в базе данных или хранилище.
Delete (удаление) - метод для удаления существующей записи или объекта из базы данных или хранилища.
# Дженерики github.com/cheekybits/genny
# Строгая типизация в Go означает, что каждая переменная имеет определенный тип, и этот тип неявно не может изменяться или преобразовываться в другой тип без явного приведения типов.

# Пример Human Worker
type Human struct {
	company string
	Name    string
	Height  float64
	Weight  float64
}

func NewHuman(newName string, newHeight float64, newWight float64) *Human {
	company := "Peps"
	return &Human{company, newName, newHeight, newWight}
}

func (h *Human) Print() {
	fmt.Println(h.company, h.Name, h.Weight, h.Height)
}

// Geter
func (h *Human) GetCompany() string {
	return h.company
}

// Seter Проверка на заглавную
func (h *Human) SetCompany(newCompany string) {
	company := []rune(newCompany)
	if !unicode.IsUpper(company[0]) {
		company[0] = unicode.ToUpper(company[0])
		h.company = string(company)
	} else {
		h.company = newCompany
	}
}

type Worker struct {
	Human
	Expirience int
}

func NewWorker(h Human, NewExp int) *Worker {
	return &Worker{h, NewExp}
}

func (w Worker) Print() {
	w.Human.Print()
	fmt.Println("Expirience: ", w.Expirience, " month")
}

func main() {
	Vasja := Human{
		Name:   "Vasul",
		Height: 1.87,
		Weight: 82,
	}
	Vasja.SetCompany("cocaCola")

	Petja := NewHuman("Petja", 1.66, 77)
	Vasja.Print()
	Petja.Print()
	PetjaWorker := NewWorker(*Petja, 3)
	PetjaWorker.Print()
}

# Какие то хотелки и требования
-  Парадигмы програмирования - хочу полностью
     обьектно ор прогр - 4 понятия (Абстракция, инкапсуляцмя, полиморфизм, Наследование
Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь 
в особенности их реализации.
 Абстракция данных — одно из наиболее старых понятий объектно-ориентированного программирования, возникшее ещё 
      до его появления. Абстракция данных связывает лежащий в основе тип данных с набором операций над ним
      (см. также абстрактный тип данных). Пользователь типа данных не имеет прямого доступа к его реализации, 
       но может работать с данными через предоставленный набор операций. Преимущество абстракции данных в разделении 
       операций над данными и внутреннего представления этих данных, что позволяет изменять реализацию, не затрагивая 
       пользователей типа данных.[1]
         Такое разделение может быть выражено через специальный «интерфейс», сосредотачивающий описание всех возможных 
       применений программы[2].
   Инкапсуляция (англ. encapsulation, от лат. in capsula) — в информатике, процесс разделения элементов абстракций, 
       определяющих ее структуру (данные) и поведение (методы); инкапсуляция предназначена для изоляции контрактных 
       обязательств абстракции (протокол/интерфейс) от их реализации. На практике это означает, что класс должен состоять
       из двух частей: интерфейса и реализации. В реализации большинства языков программирования (C++, C#, Java и другие)
       обеспечивается механизм сокрытия, позволяющий разграничивать доступ к различным частям компонента.       
   Наследование (англ. inheritance) — концепция объектно-ориентированного программирования, согласно которой 
       абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа,
       способствуя повторному использованию компонентов программного обеспечения.
        наверное конструкторы ??? интерфейсы...хз
   Полиморфизм в языках программирования и теории типов — способность функции обрабатывать данные разных типов[1][2][3].
        Привидение разных типов к одному
# Требования
 - алгоритмы

 - структури данных),
 - линукс файлов система
 - линукс - баш - команд лайн, лс дир 
 - сети протоколы днс iр https://deltahost.ua/tipy-setevyx-protokolov-i-ix-naznachenie-http-ip-ssh-ftp-pop3-mac.html
 - семь уровней сетевой модели оси юдп ип субнетворк снифери,
#